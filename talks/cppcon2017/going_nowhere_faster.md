name: title-layout
layout: true
class: center, middle, title

---
name: basic-layout
layout: true
class: left, top

---
name: title
template: title-layout

# Going Nowhere Faster
.footnote[Chandler Carruth, <chandlerc@gmail.com>, [@chandlerc1024](https://twitter.com/chandlerc1024)]

???
Intro:
- I'm Chandler Carruth
- I'm the lead for Google's C++ PL platform
- Also one of the core developers on the LLVM open source compiler project
- Obsessed with performance and optimization.

This is the third talk I'm giving on performance here at CppCon, super excited
to be back.

---
name: reflect
template: title-layout

1. Use efficient algorithms, fast data structures & idioms
1. Benchmark the code that matters, understand why
1. Use hybrid data structures to optimize allocations & cache locality

???
T+2 minutes -- take it slow to let folks settle

---
name: benchmark
template: title-layout

# You only care about performance that you benchmark!

---
name: you-have-a-loop
template: title-layout

# So you have a loop in a benchmark...

???
T+3 minutes -- ok, wrap up the slow intro, let's get down to business

---
name: data-oriented
template: title-layout

# It's probably the data...
- Watch Mike Acton's talk; use data-oriented design
- See my talk about profiling, but use counters to track cache miss rates
- In the future, use tools like Efficiency Sanitizer to optimize data structures

???
30 seconds of talking here worthwhile. give some context for ESan.

TODO(chandlerc): build a benchmark that suffers from cache misses and use perf live to catch it.
This will take 1-2 minutes to walk through, 1-2 minutes to benchmark, use perf events, and explain how it catches this

---
name: small-loops
template: title-layout

# What about small, tight loops?

???
T+8 minutes here, pick it up if T+10

Look at a simple "clamp" loop microbenchmark

- Show the most basic clamp loop (30s)
- Draw analogy to zlib and other compression algos for why this matters, get it all building and running (1m)
- discuss "obvious" alternatives on x86: cmov vs. branch (30s)
- (hopefully) show cmov being sloooooooow. why? don't switch to perf counters or profile deeply yet (30s

---
name: ooo-start
template: title-layout

# Modern processors are highly speculative

???
T+10 minutes

TODO: insert OOO demo from Jakub's keynote here

---
name: ooo-dot-cpp
template: basic-layout

```cpp
#include <cassert>
#include <vector>

int dot(const std::vector<int> &a,
        const std::vector<int> &b) {
  int sum = 0;
  assert(a.size() == b.size());
  for (int i = 0; i < a.size(); ++i)
    sum += a[i] * b[i];
  return sum;
}
```

???
To examine how modern processors work, let's look at an example with less
control flow but more actual code. Dot product.

When we compile this code for x86 (and turn off a bunch of fancy compiler
optimizations) we get some fairly simple x86 code.

---
name: ooo-dot-x86
template: basic-layout

.left-col[
```unix_assembly
.LBB0_2:
        movl    (%rsi,%rdi,4), %ecx
        imull   (%r8,%rdi,4), %ecx
        addl    %ecx, %eax
        addq    $1, %rdi
        cmpq    %rdi, %rdx
        ja      .LBB0_2
```
]
.right-col[
```
```
]

???
Here we have the x86 assembly for the inner loop, as generated by Clang.

However, modern x86 processors don't really execute this code, they decode this
into something called "micro-ops" or &micro;-ops.

I'm not going to try and use *exact* micro-ops, but we can use something close.
I'll also switch to a syntax that is a bit easier to read than raw x86
assembly.

---
name: ooo-dot-x86-asm-and-uops
template: basic-layout

.left-col[
```unix_assembly
.LBB0_2:
  movl    (%rsi,%rdi,4), %ecx
  imull   (%r8,%rdi,4), %ecx
  addl    %ecx, %eax
  addq    $1, %rdi
  cmpq    %rdi, %rdx
  ja      .LBB0_2
```
]
.right-col[
```
.LBB0_2:
  %ecx  = load (%rsi,%rdi,4)
  %tmp1 = load (%r8,%rdi,4)
  %ecx  = imul %tmp1, %ecx
  %eax  = add %ecx, %eax
  %rdi  = add $1, %rdi
  %flag = cmp %rdi, %rdx; ja .LBB0_2

```
]

???
Here we have separated the memory accesses from the instructions and show that
the jump is fused into the comparison. We also show the distinction between
inputs and outputs more clearly.

TODO: slide-per-uop w/ matching boxes to visually illustrate walking through

---
name: ooo-dot-x86-uops
template: basic-layout

.left-col[
]
.right-col[
```
.LBB0_2:
  %ecx  = load (%rsi,%rdi,4)
  %tmp1 = load (%r8,%rdi,4)
  %ecx  = imul %tmp1, %ecx
  %eax  = add %ecx, %eax
  %rdi  = add $1, %rdi
  %flag = cmp %rdi, %rdx; ja .LBB0_2

```
]

???
Ok, the processor takes these uops, but it knows one other thing that is really
important...

---
name: ooo-dot-x86-uops-predict
template: basic-layout

.left-col[
]
.right-col[
```
.LBB0_2:
  %ecx  = load (%rsi,%rdi,4)
  %tmp1 = load (%r8,%rdi,4)
  %ecx  = imul %tmp1, %ecx
  %eax  = add %ecx, %eax
  %rdi  = add $1, %rdi
  %flag = cmp %rdi, %rdx; ja .LBB0_2 (TAKEN)

```
]

???
It predicts that the branch here will be taken! Because of that, the processor
will look at this code as if the control flow were structured the other way...

---
name: ooo-dot-x86-uops-spec0
template: basic-layout

.left-col[
]
.right-col[
```
.LBB0_2:
  %ecx  = load (%rsi,%rdi,4)
  %tmp1 = load (%r8,%rdi,4)
  %ecx  = imul %tmp1, %ecx
  %eax  = add %ecx, %eax
  %rdi  = add $1, %rdi
  %flag = cmp %rdi, %rdx; jna .LBB0_3
  ...

.LBB0_3:
  ...
```
]

???
... because it assumes we'll keep executing the loop. Then it can imagine or
speculate the instructions continue with more iterations of the loop...

---
name: ooo-dot-x86-uops-spec1
template: basic-layout

.left-col[
]
.right-col[
```
.LBB0_2:
  %ecx  = load (%rsi,%rdi,4)
  %tmp1 = load (%r8,%rdi,4)
  %ecx  = imul %tmp1, %ecx
  %eax  = add %ecx, %eax
  %rdi  = add $1, %rdi
  %flag = cmp %rdi, %rdx; jna .LBB0_3
  %ecx  = load (%rsi,%rdi,4)
  %tmp1 = load (%r8,%rdi,4)
  %ecx  = imul %tmp1, %ecx
  %eax  = add %ecx, %eax
  %rdi  = add $1, %rdi
  %flag = cmp %rdi, %rdx; jna .LBB0_3
  %ecx  = load (%rsi,%rdi,4)
  %tmp1 = load (%r8,%rdi,4)
  %ecx  = imul %tmp1, %ecx
  %eax  = add %ecx, %eax
  %rdi  = add $1, %rdi
  %flag = cmp %rdi, %rdx; jna .LBB0_3
  ...
```
]

???
This forms the "reorder buffer" view of the instructions in the loop. Now
(from what the hardware people tell me) the processor doesn't actually *execute*
things out of a reorder buffer. Instead, it actually stores the things that it
did execute into the reorder buffer. But for our purposes its useful to use that
view to think about the potential speculative execution opportunities for the
processor.

We need one more thing, because if we want to do actual speculative
execution we need to not overwrite registers.

---
name: ooo-dot-x86-uops-spec2
template: basic-layout

.left-col[
]
.right-col[
```
.LBB0_2:
  %ecx_0  = load (%rsi,%rdi_0,4)
  %tmp1_0 = load (%r8,%rdi_0,4)
  %ecx_1  = imul %tmp1_0, %ecx_0
  %eax_1  = add %ecx_1, %eax_0
  %rdi_1  = add $1, %rdi_0
  %flag_0 = cmp %rdi_1, %rdx; jna .LBB0_3
  %ecx_2  = load (%rsi,%rdi_1,4)
  %tmp1_1 = load (%r8,%rdi_1,4)
  %ecx_3  = imul %tmp1_1, %ecx_2
  %eax_2  = add %ecx_2, %eax_1
  %rdi_2  = add $1, %rdi_1
  %flag_1 = cmp %rdi_2, %rdx; jna .LBB0_3
  %ecx_5  = load (%rsi,%rdi_2,4)
  %tmp1_2 = load (%r8,%rdi_2,4)
  %ecx_6  = imul %tmp1_2, %ecx_5
  %eax_3  = add %ecx_6, %eax_2
  %rdi_3  = add $1, %rdi_2
  %flag_2 = cmp %rdi_3, %rdx; jna .LBB0_3
  ...

```
]

???
This is handled in the processor using what is called "register rewriting". You
see, modern processors have many more physical registers than the program can
use. When executing the code, the processor rewrites the registers you use into
the physical entries in its register file.

---
name: ooo-demo
template: title-layout

# What tools can we use to identify this?

???
T+15 minutes

Back to the clamp loop

- use perf counters to show IPC and lack of stalls w/ branch, but stalls w/ cmov.
T+18 minutes

- introduce IACA, show throughput analysis
T+23 minutes

---
name: conclusion
template: title-layout

## 2.5 small size optimized structures, pointers, and bit packing

---
name: questions
template: title-layout

# Questions?

---
name: image-dummy
template: basic-layout
background-image: url(DragonFull.png)

???

---
name: code-dummy
template: basic-layout

```
```

???

---
name: two-col-dummy
template: basic-layout

.left-col[
```
```
]
.right-col[
```
```
]

???

---
name: img-dummy
template: title-layout

![Give me a pointer!](http://imgs.xkcd.com/comics/pointers.png)
.footnote[<http://xkcd.com/138/>]

???

