name: title-layout
layout: true
class: center, middle, title

---
name: basic-layout
layout: true
class: left, top

---
name: title
template: title-layout

# Going Nowhere Faster
.footnote[Chandler Carruth, <chandlerc@gmail.com>, [@chandlerc1024](https://twitter.com/chandlerc1024)]

???
Intro:
- I'm Chandler Carruth
- I'm the lead for Google's C++ PL platform
- Also one of the core developers on the LLVM open source compiler project
- Obsessed with performance and optimization.

This is the third talk I'm giving on performance here at CppCon, super excited
to be back.

---
name: reflect
class: left, middle

1. Use efficient algorithms, fast data structures & idioms
1. Benchmark the code that matters, understand why
1. Use hybrid data structures to optimize allocations & cache locality

???
T+2 minutes -- take it slow to let folks settle

---
name: benchmark
template: title-layout

## You only care about performance that you benchmark!

---
name: you-have-a-loop
template: title-layout

## So you have a loop in a benchmark...

???
T+3 minutes -- ok, wrap up the slow intro, let's get down to business

---
name: data-oriented
template: basic-layout

## It's probably the data...
- Watch Mike Acton's talk; use data-oriented design
- See my talk about profiling, but use counters to track cache miss rates
- In the future, use tools like Efficiency Sanitizer to optimize data structures

???
30 seconds of talking here worthwhile. give some context for ESan.

---
name: detecting-cache-problems
template: title-layout

## Let's try using performance counters...

???
Switch to live demo with cache benchmark.

- Walk through the code, how it is reasoning about working set size.
- Build and run benchmark
- Look at cliffs and at the processor's cache architecture
- Show performance counters with FE stall
- Find cache performance counters
- Show using cache performance counters, problems with multiplexing

Easily 5 minutes here.

---
name: small-loops
template: title-layout

# What about small, tight loops?

???
T+12 minutes here, pick it up if T+15

Look at a simple "clamp" loop microbenchmark

- Show the most basic clamp loop (1m)
- Draw analogy to zlib and other compression algos for why this matters, get it all building and running (1m)
- discuss "obvious" alternatives on x86: cmov vs. branch (30s)
- (hopefully) show cmov being sloooooooow. why? don't switch to perf counters or profile deeply yet (30s

---
name: ooo-start
template: title-layout

# Modern processors are highly speculative

???
T+15 minutes

---
name: ooo-dot-cpp
template: basic-layout

.left-col[
```cpp
#include <cassert>
#include <vector>

int dot(const std::vector<int> &a,
        const std::vector<int> &b) {
  int sum = 0;
  assert(a.size() == b.size());
  for (int i = 0; i < a.size(); ++i)
    sum += a[i] * b[i];
  return sum;
}
```
]
.right-col[
]

.footnote[Based on <http://llvm.org/devmtg/2013-04/olesen-slides.pdf>]

???
To examine how modern processors work, let's look at an example with less
control flow but more actual code. Dot product.

When we compile this code for x86 (and turn off a bunch of fancy compiler
optimizations) we get some fairly simple x86 code.

All of this is very directly based on the excellent talk about this subject by
Jakob Olesen at EuroLLVM in 2013.

---
name: ooo-dot-x86
template: basic-layout

.left-col[
```cpp
#include <cassert>
#include <vector>

int dot(const std::vector<int> &a,
        const std::vector<int> &b) {
  int sum = 0;
  assert(a.size() == b.size());
* for (int i = 0; i < a.size(); ++i)
*   sum += a[i] * b[i];
  return sum;
}
```
]
.right-col[
```text
.LBB0_2:
  movl    (%rsi,%rdi,4), %ecx
  imull   (%r8,%rdi,4), %ecx
  addl    %ecx, %eax
  addq    $1, %rdi
  cmpq    %rdi, %rdx
  ja      .LBB0_2
```
]

???
Here we have the x86 assembly for the inner loop, as generated by Clang.

---
name: ooo-dot-x86-shift
template: basic-layout

.left-col[
```text
.LBB0_2:
  movl    (%rsi,%rdi,4), %ecx
  imull   (%r8,%rdi,4), %ecx
  addl    %ecx, %eax
  addq    $1, %rdi
  cmpq    %rdi, %rdx
  ja      .LBB0_2
```
]
.right-col[
]

???
However, modern x86 processors don't really execute this code, they decode this
into something called "micro-ops" or &micro;-ops.

I'm not going to try and use *exact* micro-ops, but we can use something close.
I'll also switch to a syntax that is a bit easier to read than raw x86
assembly.

---
name: ooo-dot-x86-asm-and-uops
template: basic-layout

.left-col[
```text
.LBB0_2:
  movl    (%rsi,%rdi,4), %ecx
  imull   (%r8,%rdi,4), %ecx
  addl    %ecx, %eax
  addq    $1, %rdi
  cmpq    %rdi, %rdx
  ja      .LBB0_2
```
]
.right-col[
```text
.LBB0_2:
  %ecx  = load (%rsi,%rdi,4)
  %tmp1 = load (%r8,%rdi,4)
  %ecx  = imul %tmp1, %ecx
  %eax  = add %ecx, %eax
  %rdi  = add $1, %rdi
  %flag = cmp %rdi, %rdx; ja .LBB0_2

```
]

???
Here we have separated the memory accesses from the instructions and show that
the jump is fused into the comparison. We also show the distinction between
inputs and outputs more clearly.

TODO: slide-per-uop w/ matching boxes to visually illustrate walking through

---
name: ooo-dot-x86-asm-and-uops-step1
template: basic-layout

.left-col[
```text
.LBB0_2:
* movl    (%rsi,%rdi,4), %ecx
  imull   (%r8,%rdi,4), %ecx
  addl    %ecx, %eax
  addq    $1, %rdi
  cmpq    %rdi, %rdx
  ja      .LBB0_2
```
]
.right-col[
```text
.LBB0_2:
* %ecx  = load (%rsi,%rdi,4)
  %tmp1 = load (%r8,%rdi,4)
  %ecx  = imul %tmp1, %ecx
  %eax  = add %ecx, %eax
  %rdi  = add $1, %rdi
  %flag = cmp %rdi, %rdx; ja .LBB0_2

```
]

---
name: ooo-dot-x86-asm-and-uops-step2
template: basic-layout

.left-col[
```text
.LBB0_2:
  movl    (%rsi,%rdi,4), %ecx
  imull   `(%r8,%rdi,4)`, %ecx
  addl    %ecx, %eax
  addq    $1, %rdi
  cmpq    %rdi, %rdx
  ja      .LBB0_2
```
]
.right-col[
```text
.LBB0_2:
  %ecx  = load (%rsi,%rdi,4)
* %tmp1 = load (%r8,%rdi,4)
  %ecx  = imul %tmp1, %ecx
  %eax  = add %ecx, %eax
  %rdi  = add $1, %rdi
  %flag = cmp %rdi, %rdx; ja .LBB0_2

```
]

---
name: ooo-dot-x86-asm-and-uops-step3
template: basic-layout

.left-col[
```text
.LBB0_2:
  movl    (%rsi,%rdi,4), %ecx
* imull   (%r8,%rdi,4), %ecx
  addl    %ecx, %eax
  addq    $1, %rdi
  cmpq    %rdi, %rdx
  ja      .LBB0_2
```
]
.right-col[
```text
.LBB0_2:
  %ecx  = load (%rsi,%rdi,4)
  %tmp1 = load (%r8,%rdi,4)
* %ecx  = imul %tmp1, %ecx
  %eax  = add %ecx, %eax
  %rdi  = add $1, %rdi
  %flag = cmp %rdi, %rdx; ja .LBB0_2

```
]

---
name: ooo-dot-x86-asm-and-uops-step4
template: basic-layout

.left-col[
```text
.LBB0_2:
  movl    (%rsi,%rdi,4), %ecx
  imull   (%r8,%rdi,4), %ecx
* addl    %ecx, %eax
  addq    $1, %rdi
  cmpq    %rdi, %rdx
  ja      .LBB0_2
```
]
.right-col[
```text
.LBB0_2:
  %ecx  = load (%rsi,%rdi,4)
  %tmp1 = load (%r8,%rdi,4)
  %ecx  = imul %tmp1, %ecx
* %eax  = add %ecx, %eax
  %rdi  = add $1, %rdi
  %flag = cmp %rdi, %rdx; ja .LBB0_2

```
]

---
name: ooo-dot-x86-asm-and-uops-step5
template: basic-layout

.left-col[
```text
.LBB0_2:
  movl    (%rsi,%rdi,4), %ecx
  imull   (%r8,%rdi,4), %ecx
  addl    %ecx, %eax
* addq    $1, %rdi
  cmpq    %rdi, %rdx
  ja      .LBB0_2
```
]
.right-col[
```text
.LBB0_2:
  %ecx  = load (%rsi,%rdi,4)
  %tmp1 = load (%r8,%rdi,4)
  %ecx  = imul %tmp1, %ecx
  %eax  = add %ecx, %eax
* %rdi  = add $1, %rdi
  %flag = cmp %rdi, %rdx; ja .LBB0_2

```
]

---
name: ooo-dot-x86-asm-and-uops-step6
template: basic-layout

.left-col[
```text
.LBB0_2:
  movl    (%rsi,%rdi,4), %ecx
  imull   (%r8,%rdi,4), %ecx
  addl    %ecx, %eax
  addq    $1, %rdi
* cmpq    %rdi, %rdx
* ja      .LBB0_2
```
]
.right-col[
```text
.LBB0_2:
  %ecx  = load (%rsi,%rdi,4)
  %tmp1 = load (%r8,%rdi,4)
  %ecx  = imul %tmp1, %ecx
  %eax  = add %ecx, %eax
  %rdi  = add $1, %rdi
* %flag = cmp %rdi, %rdx; ja .LBB0_2

```
]

---
name: ooo-dot-x86-uops
template: basic-layout

.left-col[
]
.right-col[
```text
.LBB0_2:
  %ecx  = load (%rsi,%rdi,4)
  %tmp1 = load (%r8,%rdi,4)
  %ecx  = imul %tmp1, %ecx
  %eax  = add %ecx, %eax
  %rdi  = add $1, %rdi
  %flag = cmp %rdi, %rdx; ja .LBB0_2

```
]

???
Ok, the processor takes these uops, but it knows one other thing that is really
important...

---
name: ooo-dot-x86-uops-predict
template: basic-layout

.left-col[
]
.right-col[
```text
.LBB0_2:
  %ecx  = load (%rsi,%rdi,4)
  %tmp1 = load (%r8,%rdi,4)
  %ecx  = imul %tmp1, %ecx
  %eax  = add %ecx, %eax
  %rdi  = add $1, %rdi
  %flag = cmp %rdi, %rdx; `ja .LBB0_2`
                          # TAKEN!
.LBB0_3:
  ...

```
]

???
It predicts that the branch here will be taken! Because of that, the processor
will look at this code as if the control flow were structured the other way...

---
name: ooo-dot-x86-uops-spec0
template: basic-layout

.left-col[
]
.right-col[
```text
.LBB0_2:
  %ecx  = load (%rsi,%rdi,4)
  %tmp1 = load (%r8,%rdi,4)
  %ecx  = imul %tmp1, %ecx
  %eax  = add %ecx, %eax
  %rdi  = add $1, %rdi
  %flag = cmp %rdi, %rdx; jna .LBB0_3
  ...

.LBB0_3:
  ...
```
]

???
---
name: ooo-dot-x86-uops-spec0-hi
template: basic-layout

.left-col[
]
.right-col[
```text
.LBB0_2:
  %ecx  = load (%rsi,%rdi,4)
  %tmp1 = load (%r8,%rdi,4)
  %ecx  = imul %tmp1, %ecx
  %eax  = add %ecx, %eax
  %rdi  = add $1, %rdi
  %flag = cmp %rdi, %rdx; `jna` .LBB0_3
  ...

.LBB0_3:
  ...
```
]

???
... because it assumes we'll keep executing the loop. Then it can imagine or
speculate the instructions continue with more iterations of the loop...

---
name: ooo-dot-x86-uops-spec1-it2
template: basic-layout

.left-col[
]
.right-col[
```text
.LBB0_2:
  %ecx  = load (%rsi,%rdi,4)
  %tmp1 = load (%r8,%rdi,4)
  %ecx  = imul %tmp1, %ecx
  %eax  = add %ecx, %eax
  %rdi  = add $1, %rdi
  %flag = cmp %rdi, %rdx; jna .LBB0_3
* %ecx  = load (%rsi,%rdi,4)
* %tmp1 = load (%r8,%rdi,4)
* %ecx  = imul %tmp1, %ecx
* %eax  = add %ecx, %eax
* %rdi  = add $1, %rdi
* %flag = cmp %rdi, %rdx; jna .LBB0_3
  ...
```
]

???
---
name: ooo-dot-x86-uops-spec1-it3
template: basic-layout

.left-col[
]
.right-col[
```text
.LBB0_2:
  %ecx  = load (%rsi,%rdi,4)
  %tmp1 = load (%r8,%rdi,4)
  %ecx  = imul %tmp1, %ecx
  %eax  = add %ecx, %eax
  %rdi  = add $1, %rdi
  %flag = cmp %rdi, %rdx; jna .LBB0_3
  %ecx  = load (%rsi,%rdi,4)
  %tmp1 = load (%r8,%rdi,4)
  %ecx  = imul %tmp1, %ecx
  %eax  = add %ecx, %eax
  %rdi  = add $1, %rdi
* %flag = cmp %rdi, %rdx; jna .LBB0_3
* %ecx  = load (%rsi,%rdi,4)
* %tmp1 = load (%r8,%rdi,4)
* %ecx  = imul %tmp1, %ecx
* %eax  = add %ecx, %eax
* %rdi  = add $1, %rdi
* %flag = cmp %rdi, %rdx; jna .LBB0_3
  ...
```
]

???
This forms the "reorder buffer" view of the instructions in the loop. Now
(from what the hardware people tell me) the processor doesn't actually *execute*
things out of a reorder buffer. Instead, it actually stores the things that it
did execute into the reorder buffer. But for our purposes its useful to use that
view to think about the potential speculative execution opportunities for the
processor.

We need one more thing, because if we want to do actual speculative
execution we need to not overwrite registers.

---
name: ooo-dot-x86-uops-spec2
template: basic-layout

.left-col[
]
.right-col[
```text
.LBB0_2:
  %ecx_0  = load (%rsi,%rdi_0,4)
  %tmp1_0 = load (%r8,%rdi_0,4)
  %ecx_1  = imul %tmp1_0, %ecx_0
  %eax_1  = add %ecx_1, %eax_0
  %rdi_1  = add $1, %rdi_0
  %flag_0 = cmp %rdi_1, %rdx; jna .LBB0_3
  %ecx_2  = load (%rsi,%rdi_1,4)
  %tmp1_1 = load (%r8,%rdi_1,4)
  %ecx_3  = imul %tmp1_1, %ecx_2
  %eax_2  = add %ecx_2, %eax_1
  %rdi_2  = add $1, %rdi_1
  %flag_1 = cmp %rdi_2, %rdx; jna .LBB0_3
  %ecx_4  = load (%rsi,%rdi_2,4)
  %tmp1_2 = load (%r8,%rdi_2,4)
  %ecx_5  = imul %tmp1_2, %ecx_4
  %eax_3  = add %ecx_5, %eax_2
  %rdi_3  = add $1, %rdi_2
  %flag_2 = cmp %rdi_3, %rdx; jna .LBB0_3
  ...

```
]

???
This is handled in the processor using what is called "register rewriting". You
see, modern processors have many more physical registers than the program can
use. When executing the code, the processor rewrites the registers you use into
the physical entries in its register file.

OK, so how do these instructions actually get executed? This reorder buffer is
actually more about the results than the execution...

---
name: ooo-dot-x86-units
template: basic-layout

.left-col[
.exec-units[
| Cycle | Load | ALU | ALU |
| ----: | ---- | --- | --- |
| 1     |      |     |     |
| 2     |      |     |     |
| 3     |      |     |     |
| 4     |      |     |     |
| 5     |      |     |     |
| 6     |      |     |     |
| 7     |      |     |     |
| 8     |      |     |     |
| 9     |      |     |     |
| 10    |      |     |     |
| 11    |      |     |     |
| 12    |      |     |     |
| 13    |      |     |     |]
]
.right-col[
```text
.LBB0_2:
  %ecx_0  = load (%rsi,%rdi_0,4)
  %tmp1_0 = load (%r8,%rdi_0,4)
  %ecx_1  = imul %tmp1_0, %ecx_0
  %eax_1  = add %ecx_1, %eax_0
  %rdi_1  = add $1, %rdi_0
  %flag_0 = cmp %rdi_1, %rdx; jna .LBB0_3
  %ecx_2  = load (%rsi,%rdi_1,4)
  %tmp1_1 = load (%r8,%rdi_1,4)
  %ecx_3  = imul %tmp1_1, %ecx_2
  %eax_2  = add %ecx_2, %eax_1
  %rdi_2  = add $1, %rdi_1
  %flag_1 = cmp %rdi_2, %rdx; jna .LBB0_3
  %ecx_4  = load (%rsi,%rdi_2,4)
  %tmp1_2 = load (%r8,%rdi_2,4)
  %ecx_5  = imul %tmp1_2, %ecx_4
  %eax_3  = add %ecx_5, %eax_2
  %rdi_3  = add $1, %rdi_2
  %flag_2 = cmp %rdi_3, %rdx; jna .LBB0_3
  ...

```
]

???
Modern processors have multiple execution units that can process instructions.
Let's imagine an x86 processor which has one unit that can load from memory, two
that can do arithmetic, and one that can do fused compare and branches. This
isn't necessarily an accurate model of real x86 processors, but is enough to
illustrate how things execute.

So here we're going to track each cycle on our processor and show which
instruction (named by its result) is executing on that unit during that cycle.

---
name: ooo-dot-x86-unit-it1-g1
template: basic-layout

.left-col[
.exec-units[
| Cycle | Load    | ALU     | ALU     |
| ----: | ----    | ---     | ---     |
| 1     | .h[%ecx_0]  |         |         |
| 2     | .h[%tmp1_0] |         |         |
| 3     |         |         |         |
| 4     |         |         |         |
| 5     |         |         |         |
| 6     |         | .h[%ecx_1]  |         |
| 7     |         |         |         |
| 8     |         |         |         |
| 9     |         |         | .h[%eax_1]  |
| 10    |         |         |         |
| 11    |         |         |         |
| 12    |         |         |         |
| 13    |         |         |         |]
]
.right-col[
```text
.LBB0_2:
* %ecx_0  = load (%rsi,%rdi_0,4)
* %tmp1_0 = load (%r8,%rdi_0,4)
* %ecx_1  = imul %tmp1_0, %ecx_0
* %eax_1  = add %ecx_1, %eax_0
  %rdi_1  = add $1, %rdi_0
  %flag_0 = cmp %rdi_1, %rdx; jna .LBB0_3
  %ecx_2  = load (%rsi,%rdi_1,4)
  %tmp1_1 = load (%r8,%rdi_1,4)
  %ecx_3  = imul %tmp1_1, %ecx_2
  %eax_2  = add %ecx_2, %eax_1
  %rdi_2  = add $1, %rdi_1
  %flag_1 = cmp %rdi_2, %rdx; jna .LBB0_3
  %ecx_4  = load (%rsi,%rdi_2,4)
  %tmp1_2 = load (%r8,%rdi_2,4)
  %ecx_5  = imul %tmp1_2, %ecx_4
  %eax_3  = add %ecx_5, %eax_2
  %rdi_3  = add $1, %rdi_2
  %flag_2 = cmp %rdi_3, %rdx; jna .LBB0_3
  ...

```
]

???

---
name: ooo-dot-x86-unit-it1-g2
template: basic-layout

.left-col[
.exec-units[
| Cycle | Load    | ALU     | ALU     |
| ----: | ----    | ---     | ---     |
| 1     | %ecx_0  | .h[%rdi_1]  |         |
| 2     | %tmp1_0 |         | .h[%flag_0] |
| 3     |         |         |         |
| 4     |         |         |         |
| 5     |         |         |         |
| 6     |         | %ecx_1  |         |
| 7     |         |         |         |
| 8     |         |         |         |
| 9     |         |         | %eax_1  |
| 10    |         |         |         |
| 11    |         |         |         |
| 12    |         |         |         |
| 13    |         |         |         |]
]
.right-col[
```text
.LBB0_2:
  %ecx_0  = load (%rsi,%rdi_0,4)
  %tmp1_0 = load (%r8,%rdi_0,4)
  %ecx_1  = imul %tmp1_0, %ecx_0
  %eax_1  = add %ecx_1, %eax_0
* %rdi_1  = add $1, %rdi_0
* %flag_0 = cmp %rdi_1, %rdx; jna .LBB0_3
  %ecx_2  = load (%rsi,%rdi_1,4)
  %tmp1_1 = load (%r8,%rdi_1,4)
  %ecx_3  = imul %tmp1_1, %ecx_2
  %eax_2  = add %ecx_2, %eax_1
  %rdi_2  = add $1, %rdi_1
  %flag_1 = cmp %rdi_2, %rdx; jna .LBB0_3
  %ecx_4  = load (%rsi,%rdi_2,4)
  %tmp1_2 = load (%r8,%rdi_2,4)
  %ecx_5  = imul %tmp1_2, %ecx_4
  %eax_3  = add %ecx_5, %eax_2
  %rdi_3  = add $1, %rdi_2
  %flag_2 = cmp %rdi_3, %rdx; jna .LBB0_3
  ...

```
]

???

---
name: ooo-dot-x86-unit-it2
template: basic-layout

.left-col[
.exec-units[
| Cycle | Load    | ALU     | ALU     |
| ----: | ----    | ---     | ---     |
| 1     | %ecx_0  | %rdi_1  |         |
| 2     | %tmp1_0 | .h[%rdi_2]  | %flag_0 |
| 3     | .h[%ecx_2]  |         | .h[%flag_1] |
| 4     | .h[%tmp1_1] |         |         |
| 5     |         |         |         |
| 6     |         | %ecx_1  |         |
| 7     |         |         |         |
| 8     |         | .h[%ecx_3]  |         |
| 9     |         |         | %eax_1  |
| 10    |         |         |         |
| 11    |         |         | .h[%eax_2]  |
| 12    |         |         |         |
| 13    |         |         |         |]
]
.right-col[
```text
.LBB0_2:
  %ecx_0  = load (%rsi,%rdi_0,4)
  %tmp1_0 = load (%r8,%rdi_0,4)
  %ecx_1  = imul %tmp1_0, %ecx_0
  %eax_1  = add %ecx_1, %eax_0
  %rdi_1  = add $1, %rdi_0
  %flag_0 = cmp %rdi_1, %rdx; jna .LBB0_3
* %ecx_2  = load (%rsi,%rdi_1,4)
* %tmp1_1 = load (%r8,%rdi_1,4)
* %ecx_3  = imul %tmp1_1, %ecx_2
* %eax_2  = add %ecx_2, %eax_1
* %rdi_2  = add $1, %rdi_1
* %flag_1 = cmp %rdi_2, %rdx; jna .LBB0_3
  %ecx_4  = load (%rsi,%rdi_2,4)
  %tmp1_2 = load (%r8,%rdi_2,4)
  %ecx_5  = imul %tmp1_2, %ecx_4
  %eax_3  = add %ecx_5, %eax_2
  %rdi_3  = add $1, %rdi_2
  %flag_2 = cmp %rdi_3, %rdx; jna .LBB0_3
  ...

```
]

???

---
name: ooo-dot-x86-unit-it3
template: basic-layout

.left-col[
.exec-units[
| Cycle | Load    | ALU     | ALU     |
| ----: | ----    | ---     | ---     |
| 1     | %ecx_0  | %rdi_1  |         |
| 2     | %tmp1_0 | %rdi_2  | %flag_0 |
| 3     | %ecx_2  | .h[%rdi_3]  | %flag_1 |
| 4     | %tmp1_1 |         | .h[%flag_2] |
| 5     | .h[%ecx_4]  |         |         |
| 6     | .h[%tmp1_2] | %ecx_1  |         |
| 7     |         |         |         |
| 8     |         | %ecx_3  |         |
| 9     |         |         | %eax_1  |
| 10    |         | .h[%ecx_5]  |         |
| 11    |         |         | %eax_2  |
| 12    |         |         |         |
| 13    |         |         | .h[%eax_3]  |]
]
.right-col[
```text
.LBB0_2:
  %ecx_0  = load (%rsi,%rdi_0,4)
  %tmp1_0 = load (%r8,%rdi_0,4)
  %ecx_1  = imul %tmp1_0, %ecx_0
  %eax_1  = add %ecx_1, %eax_0
  %rdi_1  = add $1, %rdi_0
  %flag_0 = cmp %rdi_1, %rdx; jna .LBB0_3
  %ecx_2  = load (%rsi,%rdi_1,4)
  %tmp1_1 = load (%r8,%rdi_1,4)
  %ecx_3  = imul %tmp1_1, %ecx_2
  %eax_2  = add %ecx_2, %eax_1
  %rdi_2  = add $1, %rdi_1
  %flag_1 = cmp %rdi_2, %rdx; jna .LBB0_3
* %ecx_4  = load (%rsi,%rdi_2,4)
* %tmp1_2 = load (%r8,%rdi_2,4)
* %ecx_5  = imul %tmp1_2, %ecx_4
* %eax_3  = add %ecx_5, %eax_2
* %rdi_3  = add $1, %rdi_2
* %flag_2 = cmp %rdi_3, %rdx; jna .LBB0_3
  ...

```
]

???

---
name: ooo-dot-x86-unit-itN
template: basic-layout

.left-col[
.exec-units[

|       |         |         |         |
| ----: | ----    | ---     | ---     |
| 3     | %ecx_2  | %rdi_3  | %flag_1 |
| 4     | %tmp1_1 | %rdi_4  | %flag_2 |
| 5     | %ecx_4  | %rdi_5  | %flag_3 |
| 6     | %tmp1_2 | %ecx_1  | %flag_4 |
| 7     | %ecx_6  | %rdi_6  |         |
| 8     | %tmp1_3 | %ecx_3  | %flag_5 |
| 9     | %ecx_8  | .h[%rdi_7]  | %eax_1  |
| 10    | %tmp1_4 | %ecx_5  | .h[%flag_6] |
| 11    | %ecx_10 | %rdi_8  | %eax_2  |
| 12    | %tmp1_5 | %ecx_7  | %flag_7 |
| 13    | .h[%ecx_12] | %rdi_9  | %eax_3  |
| 14    | .h[%tmp1_6] | %ecx_9  | %flag_8 |
| 15    | %ecx_14 | %rdi_10 | %eax_4  |
| 16    | %tmp1_7 | %ecx_11 | %flag_9 |
| 17    | %ecx_16 | %rdi_11 | %eax_5  |
| 18    | %tmp1_8 | .h[%ecx_13] | %flag_10 |
| 19    | %ecx_18 | %rdi_12 | %eax_6  |
| 20    | %tmp1_9 | %ecx_15 | %flag_11 |
| 21    | %ecx_20 | %rdi_13 | .h[%eax_7]  |]
]
.right-col[
```text
.LBB0_2:
  %ecx_0  = load (%rsi,%rdi_0,4)
  %tmp1_0 = load (%r8,%rdi_0,4)
  %ecx_1  = imul %tmp1_0, %ecx_0
  %eax_1  = add %ecx_1, %eax_0
  %rdi_1  = add $1, %rdi_0
  %flag_0 = cmp %rdi_1, %rdx; jna .LBB0_3
  %ecx_2  = load (%rsi,%rdi_1,4)
  %tmp1_1 = load (%r8,%rdi_1,4)
  %ecx_3  = imul %tmp1_1, %ecx_2
  %eax_2  = add %ecx_2, %eax_1
  %rdi_2  = add $1, %rdi_1
  %flag_1 = cmp %rdi_2, %rdx; jna .LBB0_3
  %ecx_4  = load (%rsi,%rdi_2,4)
  %tmp1_2 = load (%r8,%rdi_2,4)
  %ecx_5  = imul %tmp1_2, %ecx_4
  %eax_3  = add %ecx_5, %eax_2
  %rdi_3  = add $1, %rdi_2
  %flag_2 = cmp %rdi_3, %rdx; jna .LBB0_3
  ...

```
]

???

---
name: ooo-demo
template: title-layout

# What tools can we use to help with this?

???
T+15 minutes

Ok, this is *really* complicated. We're going to need help, we're going to need
tools. What tools do we have?

Let's go back to the clamp loop

- use perf counters to show IPC and lack of stalls w/ branch, but stalls w/ cmov.
T+18 minutes

- introduce IACA, show throughput analysis
T+23 minutes

---
name: conclusion
template: title-layout

## Hopefully this at least serves a basis for understanding loop performace!

---
name: questions
template: title-layout

# Questions?

???

